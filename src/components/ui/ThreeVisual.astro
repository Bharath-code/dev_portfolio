<div id="three-container" class="absolute inset-0 z-0"></div>

<script>
    import * as THREE from "three";
    import { gsap } from "gsap";

    class ThreeScene {
        container: HTMLElement | null;
        scene: THREE.Scene | undefined;
        camera: THREE.PerspectiveCamera | undefined;
        renderer: THREE.WebGLRenderer | undefined;
        material: THREE.ShaderMaterial | undefined;
        mesh: THREE.Mesh | undefined;
        animationId: number | undefined;
        resizeHandler: (() => void) | undefined;
        mouseHandler: ((e: any) => void) | undefined;
        targetMouse: { x: number; y: number } = { x: 0, y: 0 };
        mouse: { x: number; y: number } = { x: 0, y: 0 };
        isVisible: boolean = true;
        observer: IntersectionObserver | undefined;

        constructor() {
            this.container = document.getElementById("three-container");
            if (!this.container) return;

            this.scene = new THREE.Scene();
            this.setupCamera();
            this.setupRenderer();
            this.setupObject();
            this.setupEventListeners();
            this.animate();
        }

        setupCamera() {
            const container = this.container;
            if (!container) return;
            this.camera = new THREE.PerspectiveCamera(
                75,
                container.offsetWidth / container.offsetHeight,
                0.1,
                1000,
            );
            this.camera.position.z = 2.5;
        }

        setupRenderer() {
            const container = this.container;
            if (!container) return;
            this.renderer = new THREE.WebGLRenderer({
                alpha: true,
                antialias: true,
            });
            this.renderer.setSize(
                container.offsetWidth,
                container.offsetHeight,
            );
            this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(this.renderer.domElement);
        }

        setupObject() {
            // Optimized: Reduced subdivisions from 64 to 32 for better performance on mobile/low-end devices
            // This reduces the vertex count from ~41k to ~10k while maintaining the 'liquid' visual.
            const geometry = new THREE.IcosahedronGeometry(1, 32);
            this.material = new THREE.ShaderMaterial({
                vertexShader: `
                    varying vec2 vUv;
                    varying float vDisplacement;
                    uniform float uTime;

                    vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                    vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                    vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
                    vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

                    float snoise(vec3 v) { 
                      const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
                      const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);

                      vec3 i  = floor(v + dot(v, C.yyy) );
                      vec3 x0 =   v - i + dot(i, C.xxx) ;

                      vec3 g = step(x0.yzx, x0.xyz);
                      vec3 l = 1.0 - g;
                      vec3 i1 = min( g.xyz, l.zxy );
                      vec3 i2 = max( g.xyz, l.zxy );

                      vec3 x1 = x0 - i1 + C.xxx;
                      vec3 x2 = x0 - i2 + C.yyy;
                      vec3 x3 = x0 - D.yyy;

                      i = mod289(i); 
                      vec4 p = permute( permute( permute( 
                                 i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
                               + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) 
                               + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));

                      float n_ = 0.142857142857;
                      vec3  ns = n_ * D.wyz - D.xzx;

                      vec4 j = p - 49.0 * floor(p * ns.z * ns.z);

                      vec4 x_ = floor(j * ns.z);
                      vec4 y_ = floor(j - 7.0 * x_ );

                      vec4 x = x_ *ns.x + ns.yyyy;
                      vec4 y = y_ *ns.x + ns.yyyy;
                      vec4 h = 1.0 - abs(x) - abs(y);

                      vec4 b0 = vec4( x.xy, y.xy );
                      vec4 b1 = vec4( x.zw, y.zw );

                      vec4 s0 = floor(b0)*2.0 + 1.0;
                      vec4 s1 = floor(b1)*2.0 + 1.0;
                      vec4 sh = -step(h, vec4(0.0));

                      vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
                      vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;

                      vec3 p0 = vec3(a0.xy,h.x);
                      vec3 p1 = vec3(a0.zw,h.y);
                      vec3 p2 = vec3(a1.xy,h.z);
                      vec3 p3 = vec3(a1.zw,h.w);

                      vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
                      p0 *= norm.x;
                      p1 *= norm.y;
                      p2 *= norm.z;
                      p3 *= norm.w;

                      vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                      m = m * m;
                      return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );
                    }

                    void main() {
                        vUv = uv;
                        float noise = snoise(vec3(position * 1.5 + uTime * 0.3));
                        vDisplacement = noise;
                        vec3 newPosition = position + normal * noise * 0.2;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
                    }
                `,
                fragmentShader: `
                    varying vec2 vUv;
                    varying float vDisplacement;
                    uniform float uTime;
                    
                    void main() {
                        vec3 baseColor = vec3(0.06, 0.72, 0.5); 
                        float alpha = smoothstep(-1.0, 1.0, vDisplacement) * 0.5;
                        vec3 finalColor = baseColor + (vDisplacement * 0.3);
                        gl_FragColor = vec4(finalColor, alpha);
                    }
                `,
                uniforms: {
                    uTime: { value: 0 },
                },
                transparent: true,
                wireframe: true,
            });

            this.mesh = new THREE.Mesh(geometry, this.material);
            if (this.scene) {
                this.scene.add(this.mesh);
            }

            // Power Optimization: Pause rendering when off-screen
            this.isVisible = true;
            this.observer = new IntersectionObserver(
                (entries) => {
                    this.isVisible = entries[0].isIntersecting;
                },
                { threshold: 0.1 },
            );
            if (this.container) this.observer.observe(this.container);
        }

        setupEventListeners() {
            this.resizeHandler = () => {
                const container = this.container;
                const camera = this.camera;
                const renderer = this.renderer;
                if (!container || !camera || !renderer) return;
                camera.aspect = container.offsetWidth / container.offsetHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.offsetWidth, container.offsetHeight);
            };
            window.addEventListener("resize", this.resizeHandler);

            this.targetMouse = { x: 0, y: 0 };
            this.mouse = { x: 0, y: 0 };
            this.mouseHandler = (e: any) => {
                this.targetMouse.x =
                    (e.clientX / window.innerWidth - 0.5) * 0.5;
                this.targetMouse.y =
                    -(e.clientY / window.innerHeight - 0.5) * 0.5;
            };
            window.addEventListener("mousemove", this.mouseHandler);
        }

        animate() {
            if (
                !this.renderer ||
                !this.material ||
                !this.mesh ||
                !this.scene ||
                !this.camera
            )
                return;

            this.animationId = requestAnimationFrame(this.animate.bind(this));

            // Only update/render if visible to save energy/performance
            if (!this.isVisible) return;

            this.material.uniforms.uTime.value += 0.01;

            this.mouse.x += (this.targetMouse.x - this.mouse.x) * 0.05;
            this.mouse.y += (this.targetMouse.y - this.mouse.y) * 0.05;

            this.mesh.rotation.y += 0.003;
            this.mesh.rotation.x = this.mouse.y;
            this.mesh.rotation.z = this.mouse.x;

            this.renderer.render(this.scene, this.camera);
        }

        playEntrance() {
            if (!this.camera || !this.mesh) return;

            const tl = gsap.timeline({ defaults: { ease: "expo.out" } });

            this.camera.position.z = 5;
            this.camera.fov = 100;
            this.camera.updateProjectionMatrix();

            tl.to(this.camera.position, {
                z: 2.5,
                duration: 2.5,
            }).to(
                this.camera,
                {
                    fov: 75,
                    duration: 2.5,
                    onUpdate: () => this.camera?.updateProjectionMatrix(),
                },
                0,
            );

            return tl;
        }

        dispose() {
            if (this.animationId) cancelAnimationFrame(this.animationId);
            if (this.resizeHandler)
                window.removeEventListener("resize", this.resizeHandler);
            if (this.mouseHandler)
                window.removeEventListener("mousemove", this.mouseHandler);

            if (this.renderer) {
                this.renderer.dispose();
                this.renderer.domElement.remove();
            }

            if (this.scene) {
                this.scene.traverse((object: any) => {
                    if (object.isMesh) {
                        if (object.geometry) object.geometry.dispose();
                        if (object.material) {
                            if (Array.isArray(object.material)) {
                                object.material.forEach((mat: any) =>
                                    mat.dispose(),
                                );
                            } else {
                                object.material.dispose();
                            }
                        }
                    }
                });
            }
        }
    }

    let sceneInstance: ThreeScene | undefined;
    function init() {
        if (sceneInstance) {
            sceneInstance.dispose();
        }
        sceneInstance = new ThreeScene();
    }

    init();
    document.addEventListener("astro:page-load", init);

    // Expose for orchestration
    (window as any).heroScene = {
        playEntrance: () => sceneInstance?.playEntrance(),
    };
</script>
